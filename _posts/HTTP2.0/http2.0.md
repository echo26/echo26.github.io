---
title: "HTTP 2.0"
date: 2020-11-02 17:00:00 -0400
categories: study update
___

# HTTP 2.0

## Outline
HTTP/2.0에서 추가/변경 된 부분
* 서버와 클라이언트 사이의 TCP 커넥션 위에서 동작한다. 클라이언트가 TCP 커넥션을 초기화
* 요청과 응답은 길이가 정의된 한개 이상의 프레임에 담긴다. HTTP 헤더는 압축되어서 담긴다.
* 요청과 응답은 스트림을 통해 보내진다. 하나의 커넥션 위에 여러개의 스트림이 동시에 만들어져서 동시에 여러 요청 응답 처리가 가능 (스트림에 대한 흐름 제어와 우선순위 부여 기능도 있음)
* 서버 푸시 적용 : 명시적 요청 없이 서버에서 클라이언트로 응답을 보낼 수 있음
* 응답 메세지는 HTTP 1.1과 같도록 유지

### Frame
HTTP 2.0에서는 모든 메세지가 HTTP/2.0에 담겨 전송된다.


### Stream & Multiplexing
*Stream* 이란 커넥션을 통해 클라이언트와 서버 사이에서 교환되는 프레임들의 독립된 양방향 시퀀스이다.

| HTTP1.0 | HTTP 2.0 |
| ----- | ----- |
| 한 TCP 커넥션을 통해 요청을 보내면, 그에 대한 응답이 도착하고 나서야 같은 TCP 커넥션으로 다시 요청을 보낼 수 있음 | 하나의 커넥션에 여러개의 스트림이 동시에 열릴 수 있어, 여러개의 요청이 동시에 보내질 수 있다. |
| 여러개의 커넥션을 만들어 동시에 보내는 방법 사용. 그럼에도 Latency 발생. | 스트림 우선순위를 줄 수 있다. |

### Header Compression

하나의 웹 페이지에 수십~수백번의 요청이 필요해서, 해더의 크기가 latency delay + 대역폭 양쪽 모두에 실질적인 영향을 끼치게 되었다.
HPACK 에서 정의된 해더압축 방법으로 압축 한 후, '헤더 블록 조각'들 로 쪼개져서 전송된다.

### Server Push

HTTP/2.0은 서버가 하나의 요청에 대해 응답으로 여러개의 리소스를 보낼 수 있도록 해준다. (서버가 클라이언트에게 어떤 리소스를 요구할 것인지 미리 알 수 있는 상황에서 유리함)

**서버에서 PUSH_PROMISE 프레임을 보내어 미리 클라이언트에게 알려야 한다. 클라이언트는 예약됨 으로 인지. 클라이언트가 별도로 또 요청하는 상황을 피하기 위함.**

#### 주의사항
* 서버 푸시를 사용하기로 했더라도, 추가 리소스를 클라이언트에게 전달 하지 않을 수 있고, 아무런 추가 리소스 업데이트가 없더라도 추가 리소스를 전달 할 수 있다.
* 서버는 오직 안전하고, 캐시 가능하고, 본문을 포함하지 않은 요청에 대해서만 푸시를 할 수 있다.
* 푸시할 리소스는 클라이언트가 명시적으로 보낸 요청과 연관된 것이어야 한다.

* 클라이어느는 반드시 서버가 푸시한 리소스를 동일 출처 정책 (Same-Origin policy)에 따라 검사해야 한다.
* SETTINGS_ENABLE_PUSH 를 0으로 해 서버 푸시를 끌 수 있다.

## 보안 이슈
### Intermediary Encapsulation Attack
프락시가 HTTP/1.1 메세지로 변환할 때 메세지의 의미가 변질될 가능성이 있다.HTTP/2.0은 HTTP/1.1과 달리 헤더 필드의 이름과 값을 바이너리로 인코딩한다.
`HTTP/2.0` -> `HTTP/1.1`과정에서 문제 일으킬 수 있음.

### 긴 커넥션으로 인한 개인 정보 노출 우려
클라이언트와 서버 사이의 커넥션을 길게 유지함에 따라 개인 정보 유출에 노출될 수 있음.
